---
layout: post
title:  "NewKS CLI Class Walkthrough"
date:   2016-06-17 12:32:42 +0000
---


The (NewKS) gem is a revision of my (newest_kickstarter) gem, which is a simple command line interface (CLI) to access the top 20 newest projects on Kickstarter.com. This gem also allows you to receive basic information about those projects and a link to their project page. Its also pretty freaking cool that its sounds like “Nukes”…right?!

The logic behind my gem starts with a simple call to (NewKS::CLI.new) in my executable file, which references a method (.new) on the class (NewKS::CLI). The (.new) method allows me to have a new instance of the CLI class, and allows me to keep the executable file simple, by putting all of the programs heavy logic on separate pages. Lastly, I added a (.start) method after (.new) just because at this point I kind of knew where I wanted my next step to be. I wanted the (.start) method to be the point where my program really begins, and to carry the flow of my ruby program.

 My next step is to create my CLI class in its own ruby file and add the (.start) method to the CLI class. This method will allow me to dictate the flow of my program by ordering my methods sequentially. Here, my goal is to scrape and list the top 20 newest Kickstarter pages, present a menu for the user to interact with, and then end the program and let the user know. So I chose to apply the KISS method (keep it simple stupid), and name the steps as briefly as I could (list, menu, and goodbye).

Next, following the flow I set in the last step, I create my list. I started with some format just to keep everything organized for the user and myself. Skipping a line reduces the sense of clutter in the small terminal window, and asterisks provide a very minimal flair to the interface and importance to the title, so I place my title between them. At this point I am ready to provide my list, but I haven’t scraped it yet. However, I do know that all the projects I scrape should be held in a (.all) method in the (NewKS::Project) class. So I call the (NewKS::Project.all) method. I then decide that I want the list to be in an ordered list, so I add the (.each) and (.with_index(1)) methods, which allows me to take each of the projects and their index numbers starting at 1 and assign a task to them. That task is a mere (puts) method, and allows me to create my ordered list by adding the (.name) method to the project along with its index. I added a skipped line just for format here, but really the list method is complete at this point.

Moving along the agenda set in the (.start) method, I began work on the menu. The menu is the part that people will most interact with, and as such will probably be the part that is changed the most through out each version of my gem. To start my menu I decided that I wanted 3 basic functions, the ability to select a project and get more info, the ability to relist the projects, and the ability to quit the program. The ability to quit the program is the most important of them because nobody wants to be stuck in an endless loop! I decided to start this method by asking the user a question with a (puts) method. I then grabbed our user’s input with a (gets) method, and used a (.strip and .downcase) method to take away spaces and casing issues. The next thing I did was to allow the user to quit using the (while) method on our input. And lastly I added the input value to our method, as (nil), so that input is defined for my exit mechanism.

Now I’m all set to provide the next function to my users, and the relist function is the easiest. To do so I used a case method on input followed with a (while) method on (“list”). This says that given the case of the user’s input, if input equals list then take an action, and of course that action is just going to be the (list) method. This will allow a user to receive the list again, which will start the menu process at the very beginning.

My last remaining goal was to give the user the ability to see more info about a specific project. To do that I needed to first add an else statement under my when statement, which will contain an (if/else) statement to separate a valid project selection from a non-valid selection. However before I add that (if/else) statement, I need to add a new input variable to turn the user’s input selection into an integer, as it will currently be a literal quotation. I used the (.to_i) method on input to turn this into an integer and set it equal to the variable (new_input). Since the user’s input may not have been an appropriate value I needed to go above my (new_input) variable and define it as having a (nil) value. This will allow (new_input) to still have a defined value, even if it wont be valid.

Finishing up my (menu) method, I can now add the (if/else) statement. This statement is meant to derive whether the selection made is valid and either give more info on the project, or refer the user to a valid option. Since it is easier to refer the user back to the directions I did this first. Skipping down to the else section, I (puts) a phrase to the user letting them know they made a mistake before the statement ends. Because the input value still is not equal to exit, the program will default back to the original question. Now to address the (if) statement, I set the (if) condition to an input value between 1 and 20, since there are only 20 projects available. This may need to change if a gem supplies a different number of projects. Once the input has been confirmed to be valid, I ran a (.find) method on the indexed project number to pull its relevant information and store it in a project variable. The next step is to present the extra info for the project, but that is best done with another method, as the (menu) method is already pretty long. So I ran a (.more_info) method on the found project, which will be defined below.

I wanted to keep my (.more_info) method simple, so I just called attribute methods on project that will be further defined in the project class file. The attributes I chose were (.name), (.summary), (.author), and (.url). Again I also have line skips and (puts) phrases just for format. Following the order of the (menu) method, when the (.more_info) method ends, the (menu) method will again prompt the user question, which will in turn end on user input of exit. The very last step to this class is to write the (.goodbye) method, which will state (puts) a phrase letting the user know that the program has ended.

Sign up here and get a $250 discount on Learn.co with the Flatiron School: learn.co/with/IshmaelKhalid

